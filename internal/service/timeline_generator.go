package service

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/jukemori/timeline-generator/internal/models"
	"github.com/jukemori/timeline-generator/internal/openai"
	"github.com/jukemori/timeline-generator/internal/repository"
)

// TimelineGenerator is the service for generating timelines
type TimelineGenerator struct {
	openAIClient *openai.Client
	goalRepo     *repository.GoalRepository
	timelineRepo *repository.TimelineRepository
	taskRepo     *repository.TaskRepository
}

// NewTimelineGenerator creates a new TimelineGenerator
func NewTimelineGenerator(openAIClient *openai.Client) *TimelineGenerator {
	return &TimelineGenerator{
		openAIClient: openAIClient,
		goalRepo:     repository.NewGoalRepository(),
		timelineRepo: repository.NewTimelineRepository(),
		taskRepo:     repository.NewTaskRepository(),
	}
}

// GeneratedTimelineData contains timeline data generated by OpenAI
type GeneratedTimelineData struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Tasks       []struct {
		Title       string `json:"title"`
		Description string `json:"description"`
		StartDate   string `json:"start_date"`
		EndDate     string `json:"end_date"`
		Duration    string `json:"duration"`
		Priority    int    `json:"priority"`
	} `json:"tasks"`
}

// GenerateTimeline generates a timeline using OpenAI
func (g *TimelineGenerator) GenerateTimeline(userID string, input models.TimelineInput) (*models.Timeline, error) {
	ctx := context.Background()

	// Create the prompt for OpenAI
	prompt := g.createPrompt(input)
	
	// Generate timeline data using OpenAI
	response, err := g.openAIClient.GenerateCompletion(ctx, prompt)
	if err != nil {
		return nil, fmt.Errorf("failed to generate timeline: %w", err)
	}

	// Parse the response into timeline data
	var timelineData GeneratedTimelineData
	if err := json.Unmarshal([]byte(response), &timelineData); err != nil {
		return nil, fmt.Errorf("failed to parse timeline data: %w", err)
	}

	// Parse dates
	startDate, err := time.Parse("2006-01-02", input.CurrentDate)
	if err != nil {
		return nil, fmt.Errorf("invalid current date: %w", err)
	}

	var endDate time.Time
	if input.TargetDate != "" {
		endDate, err = time.Parse("2006-01-02", input.TargetDate)
		if err != nil {
			return nil, fmt.Errorf("invalid target date: %w", err)
		}
	} else {
		// Get end date from the last task
		lastTask := timelineData.Tasks[len(timelineData.Tasks)-1]
		endDate, err = time.Parse("2006-01-02", lastTask.EndDate)
		if err != nil {
			return nil, fmt.Errorf("invalid task end date: %w", err)
		}
	}

	// Create a goal
	goal, err := g.goalRepo.Create(
		userID,
		input.Goal,
		"",
		input.CurrentLevel,
		input.Goal,
		startDate,
		endDate,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create goal: %w", err)
	}

	// Create a timeline
	timeline, err := g.timelineRepo.Create(
		goal.ID,
		timelineData.Title,
		timelineData.Description,
		startDate,
		endDate,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create timeline: %w", err)
	}

	// Create tasks
	for _, taskData := range timelineData.Tasks {
		taskStartDate, err := time.Parse("2006-01-02", taskData.StartDate)
		if err != nil {
			return nil, fmt.Errorf("invalid task start date: %w", err)
		}

		taskEndDate, err := time.Parse("2006-01-02", taskData.EndDate)
		if err != nil {
			return nil, fmt.Errorf("invalid task end date: %w", err)
		}

		_, err = g.taskRepo.Create(
			timeline.ID,
			taskData.Title,
			taskData.Description,
			taskData.Duration,
			taskStartDate,
			taskEndDate,
			taskData.Priority,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to create task: %w", err)
		}
	}

	// Get the complete timeline with tasks
	return g.timelineRepo.GetByID(timeline.ID)
}

// createPrompt creates a prompt for OpenAI
func (g *TimelineGenerator) createPrompt(input models.TimelineInput) string {
	return fmt.Sprintf(`
You are a professional career and learning coach AI. Create a detailed learning timeline with specific tasks to help someone achieve their goal.

CURRENT LEVEL: %s
GOAL: %s
OBJECTIVES: %s
CURRENT DATE: %s
TARGET DATE: %s

Your response should be formatted as a JSON object with the following structure:
{
  "title": "Title of the learning plan",
  "description": "Overview description of the learning plan",
  "tasks": [
    {
      "title": "Task title",
      "description": "Detailed description of what to do",
      "start_date": "YYYY-MM-DD",
      "end_date": "YYYY-MM-DD",
      "duration": "X days/weeks",
      "priority": 1-5 (higher number means higher priority)
    },
    ...more tasks
  ]
}

Make sure dates are in YYYY-MM-DD format and are realistic based on task complexity. Break down complex goals into manageable steps. Include specific resources and measurable outcomes.
`, input.CurrentLevel, input.Goal, input.Objectives, input.CurrentDate, input.TargetDate)
}